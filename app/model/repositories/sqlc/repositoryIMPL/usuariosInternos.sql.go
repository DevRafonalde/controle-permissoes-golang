// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: usuariosInternos.sql

package repositoryIMPL

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUsuarioInterno = `-- name: CreateUsuarioInterno :one
INSERT INTO t_usuarios_internos (nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada)
VALUES ($1, $2, $3, $4, $5, NOW(), $6)
RETURNING id, nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada
`

type CreateUsuarioInternoParams struct {
	Nome            string
	Email           string
	Senha           string
	Ativo           pgtype.Bool
	TokenResetSenha pgtype.Text
	SenhaAtualizada pgtype.Bool
}

func (q *Queries) CreateUsuarioInterno(ctx context.Context, arg CreateUsuarioInternoParams) (TUsuariosInterno, error) {
	row := q.db.QueryRow(ctx, createUsuarioInterno,
		arg.Nome,
		arg.Email,
		arg.Senha,
		arg.Ativo,
		arg.TokenResetSenha,
		arg.SenhaAtualizada,
	)
	var i TUsuariosInterno
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Ativo,
		&i.TokenResetSenha,
		&i.AtualizadoEm,
		&i.SenhaAtualizada,
	)
	return i, err
}

const desativarUsuarioInterno = `-- name: DesativarUsuarioInterno :execrows
UPDATE t_usuarios_internos SET ativo = false WHERE id = $1
RETURNING id
`

func (q *Queries) DesativarUsuarioInterno(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, desativarUsuarioInterno, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findAllUsuariosInternos = `-- name: FindAllUsuariosInternos :many
SELECT id, nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada FROM t_usuarios_internos WHERE id > $1 ORDER BY id LIMIT $2
`

type FindAllUsuariosInternosParams struct {
	ID    int32
	Limit int32
}

func (q *Queries) FindAllUsuariosInternos(ctx context.Context, arg FindAllUsuariosInternosParams) ([]TUsuariosInterno, error) {
	rows, err := q.db.Query(ctx, findAllUsuariosInternos, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUsuariosInterno
	for rows.Next() {
		var i TUsuariosInterno
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Ativo,
			&i.TokenResetSenha,
			&i.AtualizadoEm,
			&i.SenhaAtualizada,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUsuarioInternoByEmail = `-- name: FindUsuarioInternoByEmail :one
SELECT id, nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada FROM t_usuarios_internos WHERE email = $1
`

func (q *Queries) FindUsuarioInternoByEmail(ctx context.Context, email string) (TUsuariosInterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioInternoByEmail, email)
	var i TUsuariosInterno
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Ativo,
		&i.TokenResetSenha,
		&i.AtualizadoEm,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioInternoById = `-- name: FindUsuarioInternoById :one
SELECT id, nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada FROM t_usuarios_internos WHERE id = $1
`

func (q *Queries) FindUsuarioInternoById(ctx context.Context, id int32) (TUsuariosInterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioInternoById, id)
	var i TUsuariosInterno
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Ativo,
		&i.TokenResetSenha,
		&i.AtualizadoEm,
		&i.SenhaAtualizada,
	)
	return i, err
}

const restaurarUsuarioInterno = `-- name: RestaurarUsuarioInterno :execrows
UPDATE t_usuarios_internos SET ativo = true WHERE id = $1
RETURNING id
`

func (q *Queries) RestaurarUsuarioInterno(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, restaurarUsuarioInterno, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setSenhaAtualizadaUsuarioInternoFalse = `-- name: SetSenhaAtualizadaUsuarioInternoFalse :execrows
UPDATE t_usuarios_internos SET senha_atualizada = false WHERE id = $1
RETURNING id
`

func (q *Queries) SetSenhaAtualizadaUsuarioInternoFalse(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, setSenhaAtualizadaUsuarioInternoFalse, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setTokenResetSenhaUsuarioInterno = `-- name: SetTokenResetSenhaUsuarioInterno :execrows
UPDATE t_usuarios_internos SET token_reset_senha = $1 WHERE id = $2
RETURNING id
`

type SetTokenResetSenhaUsuarioInternoParams struct {
	TokenResetSenha pgtype.Text
	ID              int32
}

func (q *Queries) SetTokenResetSenhaUsuarioInterno(ctx context.Context, arg SetTokenResetSenhaUsuarioInternoParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTokenResetSenhaUsuarioInterno, arg.TokenResetSenha, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSenhaUsuarioInterno = `-- name: UpdateSenhaUsuarioInterno :execrows
UPDATE t_usuarios_internos SET senha = $1, senha_atualizada = true WHERE id = $2
RETURNING id
`

type UpdateSenhaUsuarioInternoParams struct {
	Senha string
	ID    int32
}

func (q *Queries) UpdateSenhaUsuarioInterno(ctx context.Context, arg UpdateSenhaUsuarioInternoParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSenhaUsuarioInterno, arg.Senha, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateUsuarioInterno = `-- name: UpdateUsuarioInterno :one
UPDATE t_usuarios_internos
SET nome = $2, email = $3, atualizado_em = NOW()
WHERE id = $1
RETURNING id, nome, email, senha, ativo, token_reset_senha, atualizado_em, senha_atualizada
`

type UpdateUsuarioInternoParams struct {
	ID    int32
	Nome  string
	Email string
}

func (q *Queries) UpdateUsuarioInterno(ctx context.Context, arg UpdateUsuarioInternoParams) (TUsuariosInterno, error) {
	row := q.db.QueryRow(ctx, updateUsuarioInterno, arg.ID, arg.Nome, arg.Email)
	var i TUsuariosInterno
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Ativo,
		&i.TokenResetSenha,
		&i.AtualizadoEm,
		&i.SenhaAtualizada,
	)
	return i, err
}
