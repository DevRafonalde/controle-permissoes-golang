// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: usuariosExternos.sql

package repositoryIMPL

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUsuarioExterno = `-- name: CreateUsuarioExterno :one
INSERT INTO t_usuarios_externos (uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em)
VALUES ($1, $2, $3, $4, $5, $6, $7, true, NOW())
RETURNING id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada
`

type CreateUsuarioExternoParams struct {
	Uuid       pgtype.Text
	IDExterno  int32
	Nome       string
	Email      string
	Senha      string
	Documento  string
	CodReserva pgtype.Text
}

func (q *Queries) CreateUsuarioExterno(ctx context.Context, arg CreateUsuarioExternoParams) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, createUsuarioExterno,
		arg.Uuid,
		arg.IDExterno,
		arg.Nome,
		arg.Email,
		arg.Senha,
		arg.Documento,
		arg.CodReserva,
	)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const desativarUsuarioExterno = `-- name: DesativarUsuarioExterno :execrows
UPDATE t_usuarios_externos SET ativo = false WHERE id = $1 
RETURNING id
`

func (q *Queries) DesativarUsuarioExterno(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, desativarUsuarioExterno, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findAllUsuariosExternos = `-- name: FindAllUsuariosExternos :many
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE id > $1 ORDER BY id LIMIT $2
`

type FindAllUsuariosExternosParams struct {
	ID    int32
	Limit int32
}

func (q *Queries) FindAllUsuariosExternos(ctx context.Context, arg FindAllUsuariosExternosParams) ([]TUsuariosExterno, error) {
	rows, err := q.db.Query(ctx, findAllUsuariosExternos, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUsuariosExterno
	for rows.Next() {
		var i TUsuariosExterno
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.IDExterno,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Documento,
			&i.CodReserva,
			&i.Ativo,
			&i.AtualizadoEm,
			&i.TokenResetSenha,
			&i.SenhaAtualizada,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUsuarioExternoByCodReserva = `-- name: FindUsuarioExternoByCodReserva :one
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE cod_reserva = $1
`

func (q *Queries) FindUsuarioExternoByCodReserva(ctx context.Context, codReserva pgtype.Text) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioExternoByCodReserva, codReserva)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioExternoByDocumento = `-- name: FindUsuarioExternoByDocumento :one
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE documento = $1
`

func (q *Queries) FindUsuarioExternoByDocumento(ctx context.Context, documento string) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioExternoByDocumento, documento)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioExternoByEmail = `-- name: FindUsuarioExternoByEmail :one
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE email = $1
`

func (q *Queries) FindUsuarioExternoByEmail(ctx context.Context, email string) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioExternoByEmail, email)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioExternoByID = `-- name: FindUsuarioExternoByID :one
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE id = $1
`

func (q *Queries) FindUsuarioExternoByID(ctx context.Context, id int32) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioExternoByID, id)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioExternoByIDExterno = `-- name: FindUsuarioExternoByIDExterno :one
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE id_externo = $1
`

func (q *Queries) FindUsuarioExternoByIDExterno(ctx context.Context, idExterno int32) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, findUsuarioExternoByIDExterno, idExterno)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}

const findUsuarioExternoByNome = `-- name: FindUsuarioExternoByNome :many
SELECT id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada FROM t_usuarios_externos WHERE nome ILIKE '%' || $1 || '%' AND id > $2 ORDER BY id LIMIT $3
`

type FindUsuarioExternoByNomeParams struct {
	Column1 pgtype.Text
	ID      int32
	Limit   int32
}

func (q *Queries) FindUsuarioExternoByNome(ctx context.Context, arg FindUsuarioExternoByNomeParams) ([]TUsuariosExterno, error) {
	rows, err := q.db.Query(ctx, findUsuarioExternoByNome, arg.Column1, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUsuariosExterno
	for rows.Next() {
		var i TUsuariosExterno
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.IDExterno,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Documento,
			&i.CodReserva,
			&i.Ativo,
			&i.AtualizadoEm,
			&i.TokenResetSenha,
			&i.SenhaAtualizada,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restaurarUsuarioExterno = `-- name: RestaurarUsuarioExterno :execrows
UPDATE t_usuarios_externos SET ativo = true WHERE id = $1 
RETURNING id
`

func (q *Queries) RestaurarUsuarioExterno(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, restaurarUsuarioExterno, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setSenhaAtualizadaUsuarioExternoFalse = `-- name: SetSenhaAtualizadaUsuarioExternoFalse :execrows
UPDATE t_usuarios_externos SET senha_atualizada = false WHERE id = $1
RETURNING id
`

func (q *Queries) SetSenhaAtualizadaUsuarioExternoFalse(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, setSenhaAtualizadaUsuarioExternoFalse, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setTokenResetSenhaUsuarioExterno = `-- name: SetTokenResetSenhaUsuarioExterno :execrows
UPDATE t_usuarios_externos SET token_reset_senha = $1 WHERE id = $2
RETURNING id
`

type SetTokenResetSenhaUsuarioExternoParams struct {
	TokenResetSenha pgtype.Text
	ID              int32
}

func (q *Queries) SetTokenResetSenhaUsuarioExterno(ctx context.Context, arg SetTokenResetSenhaUsuarioExternoParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTokenResetSenhaUsuarioExterno, arg.TokenResetSenha, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSenhaUsuarioExterno = `-- name: UpdateSenhaUsuarioExterno :execrows
UPDATE t_usuarios_externos SET senha = $1, senha_atualizada = true WHERE id = $2
RETURNING id
`

type UpdateSenhaUsuarioExternoParams struct {
	Senha string
	ID    int32
}

func (q *Queries) UpdateSenhaUsuarioExterno(ctx context.Context, arg UpdateSenhaUsuarioExternoParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSenhaUsuarioExterno, arg.Senha, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateUsuarioExterno = `-- name: UpdateUsuarioExterno :one
UPDATE t_usuarios_externos 
SET uuid = $1, id_externo = $2, nome = $3, email = $4, senha = $5, documento = $6, cod_reserva = $7, atualizado_em = NOW()
WHERE id = $8
RETURNING id, uuid, id_externo, nome, email, senha, documento, cod_reserva, ativo, atualizado_em, token_reset_senha, senha_atualizada
`

type UpdateUsuarioExternoParams struct {
	Uuid       pgtype.Text
	IDExterno  int32
	Nome       string
	Email      string
	Senha      string
	Documento  string
	CodReserva pgtype.Text
	ID         int32
}

func (q *Queries) UpdateUsuarioExterno(ctx context.Context, arg UpdateUsuarioExternoParams) (TUsuariosExterno, error) {
	row := q.db.QueryRow(ctx, updateUsuarioExterno,
		arg.Uuid,
		arg.IDExterno,
		arg.Nome,
		arg.Email,
		arg.Senha,
		arg.Documento,
		arg.CodReserva,
		arg.ID,
	)
	var i TUsuariosExterno
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.IDExterno,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Documento,
		&i.CodReserva,
		&i.Ativo,
		&i.AtualizadoEm,
		&i.TokenResetSenha,
		&i.SenhaAtualizada,
	)
	return i, err
}
